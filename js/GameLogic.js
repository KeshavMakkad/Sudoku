let N = 9; // total Number of rows and colms
let sqrtOfN = 3; // Number of rows and colms per mini square

const gameBoard = [];

function newGame(){
  return {solutionBoard: gameBoard, userBoard: emptyGameBoard}
  creategameBoard();

  generateDiagonal();
  fillRemainingCells(0, 3);

  return gameBoard
}

// Creates a 9x9 matrix to store the sudoku board
function creategameBoard() {
  for (let i = 0; i < N; i++) {
    gameBoard[i] = [];
    for (let j = 0; j < N; j++) {
      gameBoard[i][j] = 0;
    }
  }
}

function generateDiagonal() {
  // Generates the three 3x3 diagonal boxes
  for (let i = 0; i < N; i += sqrtOfN) fillSmallGrid(i, i);
}

// Generates a random number from 1 to num;
function generateRandom(num) {
  return Math.floor(Math.random() * num + 1);
}

// fills Each and every tile with an unused number generated by the above function.
function fillSmallGrid(row, colm) {
  for (let i = row; i < row + sqrtOfN; i++) {
    for (let j = colm; j < colm + sqrtOfN; j++) {
      let numberAtIndex = generateRandom(N);
      while (usedInBox(row, colm, numberAtIndex)) {
        numberAtIndex = generateRandom(N);
      }
      gameBoard[i][j] = numberAtIndex;
    }
  }
}

// Checks if the number to be put in each cell to fill the small grid is valid or not.
function usedInBox(startRow, startColm, num) {
  for (let i = 0; i < sqrtOfN; i++) {
    for (let j = 0; j < sqrtOfN; j++) {
      if (gameBoard[startRow + i][startColm + j] === num) {
        return true;
      }
    }
  }
  return false;
}

function usedInRow(row, num) {
  for (let j = 0; j < N; j++)
    if (gameBoard[row][j] == num)
      return true;
  return false;
}

function usedInColm(colm, num) {
  for (let i = 0; i < N; i++)
    if (gameBoard[i][colm] == num)
      return true;
  return false;
}

function isPlaceable(row, colm, num) {
  return (!usedInRow(row, num) && !usedInColm(colm, num) && !usedInBox(row - row % sqrtOfN, colm - colm % sqrtOfN, num));
}

function fillRemainingCells(i, j) {
  if (i === N - 1 && j === N) {
    return true; // Finished filling the board
  }

  if (j >= N) {
    i = i + 1;
    j = 0;
  }

  if (i < sqrtOfN) {
    if (j < sqrtOfN)
      j = sqrtOfN;
  }
  else if (i < N - sqrtOfN) {
    if (j === Math.floor(i / sqrtOfN) * sqrtOfN)
      j = j + sqrtOfN;
  }
  else {
    if (j === N - sqrtOfN) {
      i = i + 1;
      j = 0;
      if (i >= N)
        return true;
    }
  }

  for (let num = 1; num <= N; num++) {
    if (isPlaceable(i, j, num)) {
      gameBoard[i][j] = num;
      if (fillRemainingCells(i, j + 1)) {
        return true; // Return if the board is successfully filled
      }
      gameBoard[i][j] = 0; // Backtrack if filling the cell didn't lead to a solution
    }
  }
  return false;
}

let emptyGameBoard = JSON.stringify(gameBoard);
emptyGameBoard = JSON.parse(emptyGameBoard);

const emptyGameBoardExport = emptyGameBoard

function removeKEle(k) {
  for (let i = 0; i < k;) {
    let rowIndex = generateRandom(9) - 1;
    let colmIndex = generateRandom(9) - 1;
    if (emptyGameBoard[rowIndex][colmIndex] !== 0) {
      emptyGameBoard[rowIndex][colmIndex] = 0;
      i++;
    }
  }
}

removeKEle(40)
// Use HashMap In used reow , colm ,blah blah

// 55 - Hard
// 40 - medium
// 25 -easy